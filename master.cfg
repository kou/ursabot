# -*- python -*-
# ex: set filetype=python:

import toolz
import operator

from buildbot.plugins import (worker, steps, changes, schedulers, util,
                              reporters)

from ursabot.docker import worker_images
from ursabot.hooks import GithubHook
from ursabot.utils import Config
from ursabot.factories import (BuildFactory, cpp, python, cpp_conda,
                               python_conda, ursabot_test,
                               ursabot_docker_build)


HOSTS = False


conf = Config.load()

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database.url},
    'www': {
        'port': conf.webui.port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    },
    'change_source': [
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    ]
}

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=conf.github.auth.client_id,
        clientSecret=conf.github.auth.client_secret,
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin_orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin_users
            )
        ]
    )

if conf.github.event_hook.enabled:
    c['change_hook_dialects'] = {
        'github': {
            'class': GithubHook,
            'token': conf.github.token,
            'secret': conf.github.event_hook.secret,
            'debug': conf.github.event_hook.debug,
        }
    }

if conf.github.status_push.enabled:
    c['services'].append(
        reporters.GitHubStatusPush(
            token=conf.github.token,
            verbose=conf.github.status_push.debug,
            context=util.Interpolate('buildbot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.'
        )
    )

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

# TODO: set worker's defaultProperties
# TODO: support specifying parameters to improve isolation, like:
#   cpu_shares, isolation(cgroups), mem_limit and runtime (which will be
#   required for nvidia builds)
# https://docker-py.readthedocs.io/en/stable/api.html
# docker.api.container.ContainerApiMixin.create_host_config


if HOSTS:
    c['workers'] = [
        worker.Worker('dgx1', WORKER_PASSWORD),
    ]

    # create workers for ursabot builds - using plain python docker images
    ursabot_workers = []
    for host, attribs in HOSTS.items():
        # TODO(kszucs): nicer way to filter hosts by architecture
        if 'amd64' in attribs.get('docker_archs', set()):
            # TODO(kszucs): use a plain python image with a worker
            image = 'ursalab/amd64-ubuntu-18.04-conda-python-3.7:worker'
            image_name = 'python'
            w = worker.DockerLatentWorker(
                f'{host}-{image_name}', None,
                docker_host=attribs['docker_host'],
                image=image,
                autopull=True,
                alwaysPull=True,
                hostconfig=dict(network_mode='host')
            )
            ursabot_workers.append(w)
    c['workers'].extend(ursabot_workers)

    # workers for arrow
    workers_by_image = dict()

    # Add docker latent workers, We'll have a worker per docker image on each
    # host supporting tha image's architecture.
    for image in worker_images:
        workers = []
        for host, attribs in HOSTS.items():
            # Check that architecture is supported by the host machine.
            # Docker on mac supports multiple architectures whereas docker on
            # linux doesn't.
            image_name = image.repo.replace('.', '-')
            if image.arch in attribs.get('docker_archs', set()):
                w = worker.DockerLatentWorker(
                    f'{host}-{image_name}', None,
                    docker_host=attribs['docker_host'],
                    image=str(image),  # TODO(kszucs): use image as property
                    autopull=True,
                    alwaysPull=True,
                    hostconfig=dict(network_mode='host')
                )
                workers.append(w)
        workers_by_image[image] = workers

    c['workers'].extend(toolz.concat(workers_by_image.values()))
else:
    c['workers'] = [worker.Worker('test-worker', 'test-secret')]


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'].extend([
    changes.GitPoller(
        repourl='https://github.com/apache/arrow',
        project='apache/arrow',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='apache',
        repo='arrow',
        token=conf.github.get('token'),
        branches=['master'],
        pollInterval=180,
        magic_link=True
    ),
])


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

# trigger

if HOSTS:
    # Ursabot builders
    ursabot_builders = [
        util.BuilderConfig(
            name='ursabot-test',
            factory=ursabot_test,
            workernames=[w.name for w in ursabot_workers],
            tags=['docker', 'python']
        ),
        # TODO(kszucs): it doesn't actually require a worker
        util.BuilderConfig(
            name='ursabot-docker-build',
            factory=ursabot_docker_build,
            workernames=[w.name for w in ursabot_workers],
            tags=['docker', 'python']
        )
    ]
    c['builders'] = list(ursabot_builders)  # copy

    # Arrow builders
    arrow_builders = []
    for image in worker_images:
        # Reduce the number of ARM builds
        if image.arch == 'arm64v8' and image.os.startswith('alpine'):
            continue

        # TODO(kszucs): create a mapping between the images(environments) and
        # the build factories
        if image.name.startswith('cpp'):
            if image.variant == 'conda':
                factory = cpp_conda
            else:
                factory = cpp
        elif image.name.startswith('python'):
            if image.variant == 'conda':
                factory = python_conda
            else:
                factory = python
        else:
            raise ValueError(f'Unsupported build {image.name}')

        b = util.BuilderConfig(
            name=image.repo,
            factory=factory,
            workernames=[w.name for w in workers_by_image[image]],
            tags=['docker'] + list(image.platform)
        )
        arrow_builders.append(b)

    c['builders'].extend(arrow_builders)
else:
    # for testing
    c['builders'] = [
        util.BuilderConfig(
            name='test-builder',
            workernames=['test-worker'],
            factory=BuildFactory()
        )
    ]


# trigger


####### SCHEDULERS

if HOSTS:
    def extract_names(builders):
        return [b.name for b in builders]

    c['schedulers'] = [
        schedulers.AnyBranchScheduler(
            name='arrow',
            change_filter=util.ChangeFilter(
                project='apache/arrow'
            ),
            treeStableTimer=None,
            builderNames=extract_names(arrow_builders)
        ),
        schedulers.AnyBranchScheduler(
            name='ursabot',
            change_filter=util.ChangeFilter(
                project='ursa-labs/ursabot',
            ),
            treeStableTimer=None,
            builderNames=extract_names(ursabot_builders)
        ),
        schedulers.ForceScheduler(
            name='force',
            builderNames=extract_names(ursabot_builders + arrow_builders)
        ),
        schedulers.Try_Userpass(
            name='try',
            builderNames=extract_names(ursabot_builders + arrow_builders),
            port=TRY_SCHEDULER_PORT,
            userpass=TRY_SCHEDULER_USERPASS
        )
    ]
else:
    # for testing
    c['schedulers'] = [
        schedulers.ForceScheduler(
            name='force',
            builderNames=['test-builder']
        )
    ]

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''

# if ZULIP:
#     c['services'].append(
#         reporters.MailNotifier(
#             fromaddr=EMAIL,
#             sendToInterestedUsers=False,
#             extraRecipients=[ZULIP],
#             messageFormatter=reporters.MessageFormatter(
#                 template=template,
#                 template_type='html',
#                 wantProperties=True,
#                 wantSteps=True
#             )
#         )
#     )
