# -*- python -*-
# ex: set filetype=python:

import os
import toolz
import operator

from buildbot.plugins import worker, steps, changes, util, reporters

from ursabot.hooks import GithubHook
from ursabot.utils import Config, ConfigError, Collection
from ursabot.workers import DockerLatentWorker
from ursabot.reporters import ZulipMailNotifier
from ursabot.schedulers import AnyBranchScheduler, TryScheduler, ForceScheduler
from ursabot.builders import (BuildFactory, Builder, UrsabotTest,
                              ArrowCppCondaTest, ArrowPythonCondaTest)
from ursabot.docker import arrow_images, ursabot_images


# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# default merging order is default.toml <- $URSABOT_ENV.toml <- .secrets.toml
env = os.environ.get('URSABOT_ENV')
if not env:
    raise ConfigError('Must set URSABOT_ENV environment variable!')

conf = Config.load('default.toml', f'{env}.toml')

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

############################## AUTHENTICATION ################################

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=conf.github.auth.client_id,
        clientSecret=conf.github.auth.client_secret,
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin.users
            )
        ]
    )

################################ HOOKS ########################################

if conf.github.event_hook.enabled:
    c['change_hook_dialects'] = {
        'github': {
            'class': GithubHook,
            'token': conf.github.token,
            'secret': conf.github.event_hook.secret,
            'debug': conf.github.event_hook.debug,
        }
    }

################################ REPORTERS ####################################

if conf.reporters.github_status.enabled:
    c['services'].append(
        reporters.GitHubStatusPush(
            token=conf.github.token,
            verbose=conf.github.status_push.debug,
            context=util.Interpolate('buildbot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.'
        )
    )

if conf.reporters.zulip.enabled:
    c['services'].append(
        ZulipMailNotifier(
            zulipaddr=conf.reporters.zulip.address,
            fromaddr=conf.reporters.zulip['from']
        )
    )

################################ CHANGES ######################################

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

ursabot_changes = [
    changes.GitPoller(
        repourl='https://github.com/ursa-labs/ursabot',
        project='ursa-labs/ursabot',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='ursa-labs',
        repo='ursabot',
        token=conf.github.get('token'),
        branches=['master'],
        pollInterval=180,
        magic_link=True
    )
]

arrow_changes = [
    changes.GitPoller(
        repourl='https://github.com/apache/arrow',
        project='apache/arrow',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='apache',
        repo='arrow',
        token=conf.github.get('token'),
        branches=['master'],
        pollInterval=180,
        magic_link=True
    )
]

################################ WORKERS ######################################

workers = c['workers'] = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            arch=worker.arch,
            password=None,
            docker_host=worker.docker.host,
            image=util.Property('docker_image'),
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        )
    )

workers_by_arch = workers.groupby('arch')

################################ BUILDERS #####################################

ursabot_builders = [
    UrsabotTest(workers=workers_by_arch['amd64'],
                properties={'docker_image': image})
    for image in ursabot_images.filter(tag='worker')
]

arrow_builders = [
    ArrowCppCondaTest(workers=workers_by_arch['amd64'],
                      properties={'docker_image': image})
    for image in arrow_images.filter(name='cpp', variant='conda', tag='worker')
]

################################ SCHEDULERS ###################################

c['schedulers'].extend([
    ForceScheduler(
        name='force',
        builders=c['builders']
    ),
    TryScheduler(
        name='try',
        builders=c['builders'],
        port=conf.schedulers['try'].port,
        userpass=conf.schedulers['try'].userpass.items()
    )
])

ursabot_schedulers = [
    AnyBranchScheduler(
        name='ursabot',
        change_filter=util.ChangeFilter(
            project='ursa-labs/ursabot',
        ),
        treeStableTimer=None,
        builders=ursabot_builders
    )
]

arrow_schedulers = [
    AnyBranchScheduler(
        name='arrow',
        change_filter=util.ChangeFilter(
            project='apache/arrow',
        ),
        treeStableTimer=None,
        builders=arrow_builders
    )
]

########################## ENABLE / DISABLE PROJECTS ##########################

if conf.projects.ursabot.enabled:
    c['builders'].extend(ursabot_builders)
    c['schedulers'].extend(ursabot_schedulers)
    c['change_source'].extend(ursabot_changes)

if conf.projects.arrow.enabled:
    c['builders'].extend(arrow_builders)
    c['schedulers'].extend(arrow_schedulers)
    c['change_source'].extend(arrow_changes)

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

# TODO: set worker's defaultProperties
# TODO: support specifying parameters to improve isolation, like:
#   cpu_shares, isolation(cgroups), mem_limit and runtime (which will be
#   required for nvidia builds)
# https://docker-py.readthedocs.io/en/stable/api.html
# docker.api.container.ContainerApiMixin.create_host_config

#
# if HOSTS:
#     # create workers for ursabot builds - using plain python docker images
#     ursabot_workers = []
#     for host, attribs in HOSTS.items():
#         # TODO(kszucs): nicer way to filter hosts by architecture
#         if 'amd64' in attribs.get('docker_archs', set()):
#             # TODO(kszucs): use a plain python image with a worker
#             image = 'ursalab/amd64-ubuntu-18.04-conda-python-3.7:worker'
#             image_name = 'python'
#             w = worker.DockerLatentWorker(
#                 f'{host}-{image_name}', None,
#                 docker_host=attribs['docker_host'],
#                 image=image,
#                 autopull=True,
#                 alwaysPull=True,
#                 hostconfig=dict(network_mode='host')
#             )
#             ursabot_workers.append(w)
#     c['workers'].extend(ursabot_workers)
#
#     # workers for arrow
#     workers_by_image = dict()
#
#     # Add docker latent workers, We'll have a worker per docker image on each
#     # host supporting tha image's architecture.
#     for image in worker_images:
#         workers = []
#         for host, attribs in HOSTS.items():
#             # Check that architecture is supported by the host machine.
#             # Docker on mac supports multiple architectures whereas docker on
#             # linux doesn't.
#             image_name = image.repo.replace('.', '-')
#             if image.arch in attribs.get('docker_archs', set()):
#                 w = worker.DockerLatentWorker(
#                     f'{host}-{image_name}', None,
#                     docker_host=attribs['docker_host'],
#                     image=str(image),  # TODO(kszucs): use image as property
#                     autopull=True,
#                     alwaysPull=True,
#                     hostconfig=dict(network_mode='host')
#                 )
#                 workers.append(w)
#         workers_by_image[image] = workers
#
#     c['workers'].extend(toolz.concat(workers_by_image.values()))


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

# trigger

# if HOSTS:
#     # Arrow builders
#     arrow_builders = []
#     for image in worker_images:
#         # Reduce the number of ARM builds
#         if image.arch == 'arm64v8' and image.os.startswith('alpine'):
#             continue
#
#         # TODO(kszucs): create a mapping between the images(environments) and
#         # the build factories
#         if image.name.startswith('cpp'):
#             if image.variant == 'conda':
#                 factory = cpp_conda
#             else:
#                 factory = cpp
#         elif image.name.startswith('python'):
#             if image.variant == 'conda':
#                 factory = python_conda
#             else:
#                 factory = python
#         else:
#             raise ValueError(f'Unsupported build {image.name}')
#
#         b = util.BuilderConfig(
#             name=image.repo,
#             factory=factory,
#             workernames=[w.name for w in workers_by_image[image]],
#             tags=['docker'] + list(image.platform)
#         )
#         arrow_builders.append(b)
#
#     c['builders'].extend(arrow_builders)
