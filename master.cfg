# -*- python -*-
# ex: set filetype=python:

import os
import toolz
import operator
import warnings

from buildbot.plugins import worker, steps, changes, util, reporters

from ursabot.hooks import GithubHook
from ursabot.utils import Config, ConfigError, Collection, startswith
from ursabot.workers import DockerLatentWorker
from ursabot.reporters import ZulipMailNotifier
from ursabot.schedulers import AnyBranchScheduler, TryScheduler, ForceScheduler
from ursabot.builders import (BuildFactory, Builder, UrsabotTest,
                              ArrowCppTest, ArrowCppBenchmark, ArrowPythonTest,
                              ArrowCppCondaTest, ArrowPythonCondaTest)
from ursabot.docker import arrow_images, ursabot_images


# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# default merging order is default.toml <- $URSABOT_ENV.toml <- .secrets.toml
env = os.environ.get('URSABOT_ENV', 'test')
conf = Config.load('default.toml', f'{env}.toml', '.secrets.toml')

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

############################## AUTHENTICATION ################################

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=conf.github.auth.client_id,
        clientSecret=conf.github.auth.client_secret,
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin.users
            )
        ]
    )

################################ HOOKS ########################################

if conf.github.event_hook.enabled:
    c['www']['change_hook_dialects'] = {
        'github': {
            'class': GithubHook,
            'token': conf.github.token,
            'secret': conf.github.event_hook.secret,
            'debug': conf.github.event_hook.debug,
        }
    }

################################ REPORTERS ####################################

if conf.reporters.github_status.enabled:
    c['services'].append(
        reporters.GitHubStatusPush(
            token=conf.github.token,
            verbose=conf.reporters.github_status.debug,
            context=util.Interpolate('buildbot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.'
        )
    )

if conf.reporters.zulip.enabled:
    c['services'].append(
        ZulipMailNotifier(
            zulipaddr=conf.reporters.zulip.address,
            fromaddr=conf.reporters.zulip['from']
        )
    )

################################ CHANGES ######################################

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

arrow_changes = []
ursabot_changes = []

if conf.changes.git_poller.enabled:
    ursabot_changes.append(
        changes.GitPoller(
            repourl='https://github.com/ursa-labs/ursabot',
            project='ursa-labs/ursabot',
            branch='master',
            pollInterval=180
        )
    )
    arrow_changes.append(
        changes.GitPoller(
            repourl='https://github.com/apache/arrow',
            project='apache/arrow',
            branch='master',
            pollInterval=180
        )
    )

if conf.changes.pull_request_poller.enabled:
    ursabot_changes.append(
        changes.GitHubPullrequestPoller(
            owner='ursa-labs',
            repo='ursabot',
            token=conf.github.get('token'),
            branches=['master'],
            pollInterval=180,
            magic_link=True
        )
    )
    arrow_changes.append(
        changes.GitHubPullrequestPoller(
            owner='apache',
            repo='arrow',
            token=conf.github.get('token'),
            branches=['master'],
            pollInterval=180,
            magic_link=True
        )
    )

if conf.projects.ursabot.enabled:
    c['change_source'].extend(ursabot_changes)

if conf.projects.arrow.enabled:
    c['change_source'].extend(arrow_changes)

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = c['workers'] = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            arch=worker.arch,
            password=None,
            docker_host=worker.docker.host,
            image=util.Property('docker_image'),
            autopull=True,
            alwaysPull=True,
            hostconfig=worker.docker.hostconfig,
            max_builds=worker.get('max_builds', 1)
        )
    )

workers_by_arch = workers.groupby('arch')

################################ BUILDERS #####################################
# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.


def docker_builders_for(BuilderClass, images):
    builders = []
    for image in images:
        if image.arch in workers_by_arch:
            builders.append(
                BuilderClass(
                    name=image.repo,
                    tags=list(image.platform),
                    workers=workers_by_arch[image.arch],
                    properties=dict(docker_image=str(image))
                )
            )
        else:
            warnings.warn(
                f'There are no docker workers available for architecture '
                f'`{image.arch}`, omitting image `{image}`'
            )
    return builders


ursabot_builders = docker_builders_for(
    UrsabotTest,
    ursabot_images.filter(tag='worker')
)

arrow_cpp_builders = docker_builders_for(
    ArrowCppTest,
    arrow_images.filter(
        name='cpp',
        os=startswith('ubuntu') | startswith('alpine'),
        variant=None,
        tag='worker'
    )
)
arrow_cpp_benchmark_builders = docker_builders_for(
    ArrowCppBenchmark,
    arrow_images.filter(
        name='cpp',
        os=startswith('ubuntu'),
        variant='benchmark',
        tag='worker'
    )
)
arrow_python_builders = docker_builders_for(
    ArrowPythonTest,
    arrow_images.filter(
        name=startswith('python'),
        os=startswith('ubuntu') | startswith('alpine'),
        variant=None,
        tag='worker'
    )
)
arrow_conda_cpp_builders = docker_builders_for(
    ArrowCppCondaTest,
    arrow_images.filter(
        name='cpp',
        variant='conda',
        tag='worker'
    )
)
arrow_conda_python_builders = docker_builders_for(
    ArrowPythonCondaTest,
    arrow_images.filter(
        name=startswith('python'),
        variant='conda',
        tag='worker'
    )
)

arrow_builders = (
    arrow_cpp_builders +
    arrow_python_builders +
    arrow_conda_cpp_builders +
    arrow_conda_python_builders
)

arrow_benchmark_builders = (
    arrow_cpp_benchmark_builders
)

if conf.projects.ursabot.enabled:
    c['builders'].extend(ursabot_builders)

if conf.projects.arrow.enabled:
    c['builders'].extend(arrow_builders + arrow_benchmark_builders)

################################ SCHEDULERS ###################################

force_schedulers = []

if conf.projects.arrow.enabled:
    force_schedulers.append(ForceScheduler(
        project='apache/arrow',
        name='apache-arrow-force-scheduler',
        buttonName='Build',
        label='Manual apache/arrow Build',
        builders=arrow_builders + arrow_benchmark_builders
    ))

if conf.projects.ursabot.enabled:
    force_schedulers.append(ForceScheduler(
        project='ursa-labs/ursabot',
        name='ursabot-force-scheduler',
        buttonName='Build',
        label='Manual ursa-labs/ursabot Build',
        builders=ursabot_builders
    ))

c['schedulers'].extend(force_schedulers)

if conf.schedulers['try'].enabled:
    c['schedulers'].append(
        TryScheduler(
            name='try',
            builders=c['builders'],
            port=conf.schedulers['try'].port,
            userpass=conf.schedulers['try'].userpass.items()
        )
    )

ursabot_schedulers = [
    AnyBranchScheduler(
        name='ursabot',
        change_filter=util.ChangeFilter(
            project='ursa-labs/ursabot',
        ),
        treeStableTimer=None,
        builders=ursabot_builders
    )
]

arrow_schedulers = [
    AnyBranchScheduler(
        name='arrow',
        change_filter=util.ChangeFilter(
            project='apache/arrow',
            filter_fn=lambda c: not c.properties.getProperty('is_benchmark')
        ),
        treeStableTimer=None,
        builders=arrow_builders
    ) ,
    # Ensure that benchmarks are not triggered on every commit of every PR.
    # A benchmark build is triggered by any changes with the property
    # `is_benchmark`.
    AnyBranchScheduler(
        name='arrow-benchmarks',
        change_filter=util.ChangeFilter(
            project='apache/arrow',
            filter_fn=lambda c: c.properties.getProperty('is_benchmark')
        ),
        treeStableTimer=None,
        builders=arrow_cpp_benchmark_builders
    )
]

if conf.projects.ursabot.enabled:
    c['schedulers'].extend(ursabot_schedulers)

if conf.projects.arrow.enabled:
    c['schedulers'].extend(arrow_schedulers)
