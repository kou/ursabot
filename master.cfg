# -*- python -*-
# ex: set filetype=python:

import os
import toolz
import operator
import warnings

from buildbot.plugins import worker, steps, changes, util, reporters

from ursabot.hooks import GithubHook
from ursabot.utils import Config, ConfigError, Collection, startswith
from ursabot.workers import DockerLatentWorker
from ursabot.reporters import (GitHubStatusPush, GitHubReviewPush,
                               GitHubCommentPush, ZulipMailNotifier)
from ursabot.schedulers import AnyBranchScheduler, TryScheduler, ForceScheduler
from ursabot.builders import (BuildFactory, Builder, UrsabotTest,
                              ArrowCppTest, ArrowCppBenchmark, ArrowPythonTest,
                              ArrowCppCondaTest, ArrowPythonCondaTest)
from ursabot.docker import arrow_images, ursabot_images


# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# default merging order is default.toml <- $URSABOT_ENV.toml <- .secrets.toml
env = os.environ.get('URSABOT_ENV', 'test')
conf = Config.load('default.toml', f'{env}.toml', '.secrets.toml')

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

# TODO(kszucs): create a Project abstraction to specify ursabot and arrow
# builders, schedulers, reporters in a cleaner fashion with support of enabling
# disabling each part

############################## AUTHENTICATION ################################

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=conf.github.auth.client_id,
        clientSecret=conf.github.auth.client_secret,
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin.users
            )
        ]
    )

################################ HOOKS ########################################

if conf.github.event_hook.enabled:
    c['www']['change_hook_dialects'] = {
        'github': {
            'class': GithubHook,
            'token': conf.github.token,
            'secret': conf.github.event_hook.secret,
            'debug': conf.github.event_hook.debug,
        }
    }

################################ CHANGES ######################################

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

for key, project in conf.projects.items():
    try:
        owner, repo = project.name.split('/')
    except ValueError:
        raise ConfigError(f'project.{key}.name must be in `owner/repo`'
                          f' format instead of {project.name}')

    for source_name in project.change_sources:
        if source_name == 'git_poller':
            change = changes.GitPoller(
                project=project.name,
                repourl=project.repository,
                branch='master',
                pollInterval=180
            )
        elif source_name == 'pull_request_poller':
            change = changes.GitHubPullrequestPoller(
                owner=owner,
                repo=repo,
                token=conf.github.get('token'),
                branches=['master'],
                pollInterval=180,
                magic_link=True
            )
        else:
            raise ConfigError(f'Uknown change source name in project.{key}.'
                              f'change_sources: `{source_name}`')

        if project.enabled:
            c['change_source'].append(change)

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = c['workers'] = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            arch=worker.arch,
            password=None,
            docker_host=worker.docker.host,
            image=util.Property('docker_image'),
            autopull=True,
            alwaysPull=True,
            hostconfig=worker.docker.hostconfig,
            max_builds=worker.get('max_builds', 1)
        )
    )

workers_by_arch = workers.groupby('arch')

################################ BUILDERS #####################################
# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.


def docker_builders_for(BuilderClass, images):
    builders = []
    for image in images:
        if image.arch in workers_by_arch:
            builders.append(
                BuilderClass(
                    name=image.repo,
                    tags=list(image.platform),
                    workers=workers_by_arch[image.arch],
                    properties=dict(docker_image=str(image))
                )
            )
        else:
            warnings.warn(
                f'There are no docker workers available for architecture '
                f'`{image.arch}`, omitting image `{image}`'
            )
    return builders


ursabot_builders = docker_builders_for(
    UrsabotTest,
    ursabot_images.filter(tag='worker')
)

arrow_cpp_builders = docker_builders_for(
    ArrowCppTest,
    arrow_images.filter(
        name='cpp',
        os=startswith('ubuntu') | startswith('alpine'),
        variant=None,  # plain linux images, no conda
        tag='worker'
    )
)
arrow_cpp_benchmark_builders = docker_builders_for(
    ArrowCppBenchmark,
    arrow_images.filter(
        name='cpp-benchmark',
        os=startswith('ubuntu'),
        variant=None,  # plain linux images, no conda
        tag='worker'
    )
)
arrow_python_builders = docker_builders_for(
    ArrowPythonTest,
    arrow_images.filter(
        name=startswith('python'),
        os=startswith('ubuntu') | startswith('alpine'),
        variant=None,
        tag='worker'
    )
)
arrow_conda_cpp_builders = docker_builders_for(
    ArrowCppCondaTest,
    arrow_images.filter(
        name='cpp',
        variant='conda',
        tag='worker'
    )
)
arrow_conda_python_builders = docker_builders_for(
    ArrowPythonCondaTest,
    arrow_images.filter(
        name=startswith('python'),
        variant='conda',
        tag='worker'
    )
)

arrow_builders = (
    arrow_cpp_builders +
    arrow_python_builders +
    arrow_conda_cpp_builders +
    arrow_conda_python_builders
)

arrow_benchmark_builders = (
    arrow_cpp_benchmark_builders
)

if conf.projects.ursabot.enabled:
    c['builders'].extend(ursabot_builders)

if conf.projects.arrow.enabled:
    c['builders'].extend(arrow_builders + arrow_benchmark_builders)

################################ SCHEDULERS ###################################

if conf.schedulers['try'].enabled:
    c['schedulers'].append(
        TryScheduler(
            name='try',
            builders=c['builders'],
            port=conf.schedulers['try'].port,
            userpass=conf.schedulers['try'].userpass.items()
        )
    )

if conf.projects.arrow.enabled:
    c['schedulers'].append(
        ForceScheduler(
            name='arrow-force-scheduler',
            project=conf.projects.arrow.name,
            repository=conf.projects.arrow.repository,
            builders=arrow_builders + arrow_benchmark_builders
        )
    )

if conf.projects.ursabot.enabled:
    c['schedulers'].append(
        ForceScheduler(
            name='ursabot-force-scheduler',
            project=conf.projects.ursabot.name,
            repository=conf.projects.ursabot.repository,
            builders=ursabot_builders
        )
    )

ursabot_schedulers = [
    AnyBranchScheduler(
        name='ursabot',
        change_filter=util.ChangeFilter(
            project=conf.projects.ursabot.name,
        ),
        treeStableTimer=None,
        builders=ursabot_builders
    )
]

arrow_schedulers = [
    AnyBranchScheduler(
        name='arrow',
        change_filter=util.ChangeFilter(
            project=conf.projects.arrow.name,
            filter_fn=lambda c: not c.properties.getProperty('is_benchmark')
        ),
        treeStableTimer=None,
        builders=arrow_builders
    ) ,
    # Ensure that benchmarks are not triggered on every commit of every PR.
    # A benchmark build is triggered by any changes with the property
    # `is_benchmark`.
    AnyBranchScheduler(
        name='arrow-benchmarks',
        change_filter=util.ChangeFilter(
            project=conf.projects.arrow.name,
            filter_fn=lambda c: c.properties.getProperty('is_benchmark')
        ),
        treeStableTimer=None,
        builders=arrow_cpp_benchmark_builders
    )
]

if conf.projects.ursabot.enabled:
    c['schedulers'].extend(ursabot_schedulers)

if conf.projects.arrow.enabled:
    c['schedulers'].extend(arrow_schedulers)

################################ REPORTERS ####################################

ursabot_reporters = []
arrow_reporters = []

if 'github_status' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        GitHubStatusPush(
            token=conf.github.token,
            verbose=conf.reporters.github_status.debug,
            context=util.Interpolate('ursabot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.',
            builders=ursabot_builders
        )
    )

if 'github_review' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        GitHubReviewPush(
            token=conf.github.token,
            verbose=conf.reporters.github_review.debug,
            context=util.Interpolate('ursabot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.',
            builders=ursabot_builders
        )
    )

# github_comment reporter comes here

if 'zulip' in conf.projects.ursabot.reporters:
    ursabot_reporters.append(
        ZulipMailNotifier(
            zulipaddr=conf.reporters.zulip.address,
            fromaddr=conf.reporters.zulip['from'],
            builders=ursabot_builders
        )
    )

if conf.projects.ursabot.enabled:
    c['services'].extend(ursabot_reporters)

if conf.projects.arrow.enabled:
    c['services'].extend(arrow_reporters)
