# -*- python -*-
# ex: set filetype=python:

import os
import toolz
import operator

from buildbot.plugins import worker, steps, changes, util, reporters

from ursabot.hooks import GithubHook
from ursabot.utils import Config, ConfigError, Collection
from ursabot.workers import DockerLatentWorker
from ursabot.reporters import ZulipMailNotifier
from ursabot.schedulers import AnyBranchScheduler, TryScheduler, ForceScheduler
from ursabot.builders import (BuildFactory, Builder, UrsabotTest,
                              ArrowCppCondaTest, ArrowPythonCondaTest)
from ursabot.docker import arrow_images, ursabot_images


# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# default merging order is default.toml <- $URSABOT_ENV.toml <- .secrets.toml
env = os.environ.get('URSABOT_ENV')
if not env:
    raise ConfigError('Must set URSABOT_ENV environment variable!')

conf = Config.load('default.toml', f'{env}.toml')

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

############################## AUTHENTICATION ################################

if conf.github.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=conf.github.auth.client_id,
        clientSecret=conf.github.auth.client_secret,
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.github.auth.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly give roles to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.github.auth.admin.users
            )
        ]
    )

################################ HOOKS ########################################

if conf.github.event_hook.enabled:
    c['change_hook_dialects'] = {
        'github': {
            'class': GithubHook,
            'token': conf.github.token,
            'secret': conf.github.event_hook.secret,
            'debug': conf.github.event_hook.debug,
        }
    }

################################ REPORTERS ####################################

if conf.reporters.github_status.enabled:
    c['services'].append(
        reporters.GitHubStatusPush(
            token=conf.github.token,
            verbose=conf.github.status_push.debug,
            context=util.Interpolate('buildbot/%(prop:buildername)s'),
            startDescription='Build started.',
            endDescription='Build done.'
        )
    )

if conf.reporters.zulip.enabled:
    c['services'].append(
        ZulipMailNotifier(
            zulipaddr=conf.reporters.zulip.address,
            fromaddr=conf.reporters.zulip['from']
        )
    )

################################ CHANGES ######################################

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

ursabot_changes = [
    changes.GitPoller(
        repourl='https://github.com/ursa-labs/ursabot',
        project='ursa-labs/ursabot',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='ursa-labs',
        repo='ursabot',
        token=conf.github.get('token'),
        branches=['master'],
        pollInterval=180,
        magic_link=True
    )
]

arrow_changes = [
    changes.GitPoller(
        repourl='https://github.com/apache/arrow',
        project='apache/arrow',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='apache',
        repo='arrow',
        token=conf.github.get('token'),
        branches=['master'],
        pollInterval=180,
        magic_link=True
    )
]

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = c['workers'] = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            arch=worker.arch,
            password=None,
            docker_host=worker.docker.host,
            image=util.Property('docker_image'),
            autopull=True,
            alwaysPull=True,
            hostconfig=dict(network_mode='host')
        )
    )

workers_by_arch = workers.groupby('arch')

################################ BUILDERS #####################################
# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

ursabot_builders = [
    UrsabotTest(workers=workers_by_arch['amd64'],
                properties={'docker_image': image})
    for image in ursabot_images.filter(tag='worker')
]

# cpp (amd64 arm64)
# python (amd64 arm64)
# cpp + conda (amd64)
# python + conda (amd64)
arrow_builders = [
    ArrowCppCondaTest(workers=workers_by_arch['amd64'],
                      properties={'docker_image': image})
    for image in arrow_images.filter(name='cpp', variant='conda', tag='worker')
]

################################ SCHEDULERS ###################################

c['schedulers'].extend([
    ForceScheduler(
        name='force',
        builders=c['builders']
    ),
    TryScheduler(
        name='try',
        builders=c['builders'],
        port=conf.schedulers['try'].port,
        userpass=conf.schedulers['try'].userpass.items()
    )
])

ursabot_schedulers = [
    AnyBranchScheduler(
        name='ursabot',
        change_filter=util.ChangeFilter(
            project='ursa-labs/ursabot',
        ),
        treeStableTimer=None,
        builders=ursabot_builders
    )
]

arrow_schedulers = [
    AnyBranchScheduler(
        name='arrow',
        change_filter=util.ChangeFilter(
            project='apache/arrow',
        ),
        treeStableTimer=None,
        builders=arrow_builders
    )
]

########################## ENABLE / DISABLE PROJECTS ##########################

if conf.projects.ursabot.enabled:
    c['builders'].extend(ursabot_builders)
    c['schedulers'].extend(ursabot_schedulers)
    c['change_source'].extend(ursabot_changes)

if conf.projects.arrow.enabled:
    c['builders'].extend(arrow_builders)
    c['schedulers'].extend(arrow_schedulers)
    c['change_source'].extend(arrow_changes)
