# -*- python -*-
# ex: set filetype=python:

# Copyright 2019 RStudio, Inc.
# All rights reserved.
#
# Use of this source code is governed by a BSD 2-Clause
# license that can be found in the LICENSE_BSD file.

import os
import pathlib

import toolz
from buildbot.plugins import util, changes

from ursabot.hooks import UrsabotHook
from ursabot.utils import Config, Collection
from ursabot.workers import DockerLatentWorker
from ursabot.secrets import SecretInPass


# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# merging order is default.toml <- $env.toml <- local.toml <-.secrets.toml
env = os.environ.get('URSABOT_ENV', 'test')
print(f'Loading environment: {env}')

conf = Config.load('default.yaml', f'{env}.yaml',
                   optionals=['local.yaml', '.secrets.yaml'])

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {
    'buildbotNetUsageData': None,
    'title': conf.title,
    'titleURL': conf.url,
    'buildbotURL': conf.url,
    'workers': [],
    'builders': [],
    'schedulers': [],
    'services': [],
    'change_source': [],
    'secretsProviders': [],
    'protocols': {'pb': {'port': conf.worker_port}},
    'db': {'db_url': conf.database_url},
    'www': {
        'port': conf.webui_port,
        'change_hook_dialects': {},
        'plugins': {
            'waterfall_view': {},
            'console_view': {},
            'grid_view': {}
        }
    }
}

# TODO(kszucs): create a Project abstraction to specify ursabot and arrow
# builders, schedulers, reporters in a cleaner fashion with support of enabling
# disabling each part

if conf.secrets.enabled:
    c['secretsProviders'].append(
        SecretInPass(
            passphrase=conf.secrets.get('passphrase'),
            dirname=pathlib.Path(conf.secrets.directory).expanduser()
        )
    )

############################## AUTHENTICATION ################################

if conf.auth.enabled:
    c['www']['auth'] = util.GitHubAuth(
        clientId=util.Interpolate(conf.auth.github.client_id),
        clientSecret=util.Interpolate(conf.auth.github.client_secret),
        apiVersion=4,
        getTeamsMembership=True
    )
    c['www']['authz'] = util.Authz(
        # 'admin' organization is unavalable on github so it is used to grant
        # access for specific users outside of allowed organizations
        allowRules=[
            util.AnyControlEndpointMatcher(role=org)
            for org in conf.auth.roles.admin.orgs + ['admin']
        ],
        roleMatchers=[
            # github organization names becomes the roles assigned to the user
            util.RolesFromGroups(),
            # explicitly assign admin role to specific users
            util.RolesFromUsername(
                roles=['admin'],
                usernames=conf.auth.roles.admin.users
            )
        ]
    )

################################ HOOKS ########################################
# Accept HTTP requests and translate them into changes for buildbot. We use a
# specialized hook which also processes the pull request comments.

if conf.hooks.github.enabled:
    c['www']['change_hook_dialects']['github'] = {
        'class': UrsabotHook,
        'secret': util.Interpolate(conf.hooks.github.secret),
        'token': [
            util.Interpolate(token) for token in conf.hooks.github.tokens
        ],
        'debug': conf.hooks.github.debug,
        'strict': True,
        'verify': True
    }

################################ CHANGES ######################################
# The 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

if conf.changes.pb.enabled:
    c['change_source'].append(
        changes.PBChangeSource(
            port=conf.changes.pb.port,
            user=conf.changes.pb.user,
            passwd=conf.changes.pb.password
        )
    )

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = Collection()

for worker in conf.workers:
    workers.append(
        DockerLatentWorker(
            f'{worker.name}-docker',
            password=None,
            arch=worker.arch,
            tags=worker.get('tags', []),
            max_builds=worker.get('max_builds', 1),
            properties={
                'ncpus': worker.get('ncpus')
            },
            image=util.Property('docker_image'),
            docker_host=worker.docker.host,
            masterFQDN=worker.docker.get('masterFQDN'),
            autopull=worker.docker.get('autopull', True),
            alwaysPull=worker.docker.get('alwayspull', True),
            volumes=util.Transform(
                lambda a, b: list(toolz.concat([a, b])),
                worker.docker.get('volumes', []),
                util.Property('docker_volumes', [])
            ),
            hostconfig=util.Transform(
                toolz.merge,
                worker.docker.get('hostconfig', {}),
                util.Property('docker_hostconfig', default={})
            ),
            missing_timeout=worker.docker.get('missing_timeout', 120)
        )
    )

c['workers'].extend(workers)
