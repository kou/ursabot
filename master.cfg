# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import worker, steps, changes, schedulers, util, reporters

import toolz
import operator
from ursabot.docker import worker_images
from ursabot.hooks import GithubHook

try:
    from local import (PRODUCTION, BUILDBOT_URL, ZULIP, EMAIL, WORKER_PORT,
                       HOSTS, WEBUI_PORT, AUTH, AUTHZ, DATABASE_URL,
                       WORKER_PASSWORD, CHANGE_PORT, CHANGE_USER,
                       CHANGE_PASSWORD, GITHUB_TOKEN, GITHUB_HOOK_SECRET)
except ImportError:
    from buildbot.www.auth import NoAuth
    PRODUCTION = False
    BUILDBOT_URL = 'http://localhost:9011/'
    DATABASE_URL = 'sqlite:///buildbot.sqlite'
    EMAIL = 'test@buildbot'
    ZULIP = None
    HOSTS = None
    WORKER_PORT = 9021
    WEBUI_PORT = 8080
    AUTH = NoAuth()
    AUTHZ = util.Authz()
    GITHUB_TOKEN = None
    CHANGE_PORT = 9041
    CHANGE_USER = 'test'
    CHANGE_PASSWORD = 'testpw'
    GITHUB_HOOK_SECRET = None


print(f'IS PRODUCTION: {PRODUCTION}')

# Hierarchy worker -> builder -> scheduler

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').
c['title'] = 'Apache Arrow'
c['titleURL'] = 'https://github.com/apache/arrow'
c['buildbotURL'] = BUILDBOT_URL

c['workers'] = []
c['builders'] = []
c['schedulers'] = []

####### WORKERS

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': WORKER_PORT}}

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

# TODO: set worker's defaultProperties
# TODO: support specifying parameters to improve isolation, like:
#   cpu_shares, isolation(cgroups), mem_limit and runtime (which will be
#   required for nvidia builds)
# https://docker-py.readthedocs.io/en/stable/api.html
# docker.api.container.ContainerApiMixin.create_host_config

if HOSTS:
    c['workers'] = [
        worker.Worker('dgx1', WORKER_PASSWORD)
    ]
    workers_by_image = dict()

    # Add docker latent workers, We'll have a worker per docker image on each
    # host supporting tha image's architecture.
    for image in worker_images:
        workers = []
        for host, attribs in HOSTS.items():
            # Check that architecture is supported by the host machine.
            # Docker on mac supports multiple architectures whereas docker on
            # linux doesn't.
            image_name = image.repo.replace('.', '-')
            if image.arch in attribs.get('docker_archs', set()):
                w = worker.DockerLatentWorker(
                    f'{host}-{image_name}', None,
                    docker_host=attribs['docker_host'],
                    image=str(image),
                    autopull=True,
                    alwaysPull=True,
                    hostconfig=dict(network_mode='host')
                )
                workers.append(w)
        workers_by_image[image] = workers

    c['workers'].extend(toolz.concat(workers_by_image.values()))
else:
    c['workers'] = [worker.Worker('test-worker', 'test-secret')]


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = [
    changes.GitPoller(
        'https://github.com/apache/arrow',
        workdir='gitpoller-workdir',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='apache',
        repo='arrow',
        token=GITHUB_TOKEN,
        branches=['master'],
        pollInterval=180,
    ),
    changes.PBChangeSource(port=CHANGE_PORT, user=CHANGE_USER,
                           passwd=CHANGE_PASSWORD)
]


####### FACTORIES

from ursabot.factories import (BuildFactory, cpp, python, cpp_conda,
                               python_conda)


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.


if HOSTS:
    # image_groups = toolz.groupby(operator.attrgetter('name'), worker_images)
    builders = []
    for image in worker_images:
        # Reduce the number of ARM builds
        if image.arch == 'arm64v8' and image.os.startswith('alpine'):
            continue

        # TODO(kszucs): create a mapping between the images(environments) and
        # the build factories
        if image.name.startswith('cpp'):
            if image.variant == 'conda':
                factory = cpp_conda
            else:
                factory = cpp
        elif image.name.startswith('python'):
            if image.variant == 'conda':
                factory = python_conda
            else:
                factory = python
        else:
            raise ValueError(f'Unsupported build {image.name}')

        b = util.BuilderConfig(
            name=image.repo,
            factory=factory,
            workernames=[w.name for w in workers_by_image[image]],
            tags=['docker'] + list(image.platform)
        )
        builders.append(b)

    c['builders'].extend(builders)
else:
    # for testing
    c['builders'] = [
        util.BuilderConfig(
            name='test-builder',
            workernames=['test-worker'],
            factory=BuildFactory()
        )
    ]


####### SCHEDULERS

if HOSTS:
    builders = [b.name for b in builders]

    c['schedulers'] = [
        schedulers.SingleBranchScheduler(
            name='all',
            change_filter=util.ChangeFilter(branch='master'),
            treeStableTimer=None,
            builderNames=builders
        ),
        schedulers.ForceScheduler(
            name='force',
            builderNames=builders
        )
    ]
else:
    # for testing
    c['schedulers'] = [
        schedulers.ForceScheduler(
            name='force',
            builderNames=['test-builder']
        )
    ]

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''

if ZULIP:
    c['services'] = [
        reporters.MailNotifier(
            fromaddr=EMAIL,
            sendToInterestedUsers=False,
            extraRecipients=[ZULIP],
            messageFormatter=reporters.MessageFormatter(
                template=template,
                template_type='html',
                wantProperties=True,
                wantSteps=True
            )
        )
    ]

# minimalistic config to activate new web UI
c['www'] = dict(
    port=WEBUI_PORT,
    auth=AUTH,
    authz=AUTHZ,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={}
    ),
    change_hook_dialects={
        'github': {
            'class': GithubHook,
            'token': GITHUB_TOKEN,
            'secret': GITHUB_HOOK_SECRET,
            'debug': True,
        }
    }
)

####### DB URL

c['db'] =  {'db_url' : DATABASE_URL}
