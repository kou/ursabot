# -*- python -*-
# ex: set filetype=python:

# Copyright 2019 RStudio, Inc.
# All rights reserved.
#
# Use of this source code is governed by a BSD 2-Clause
# license that can be found in the LICENSE_BSD file.
import os
from pathlib import Path

from buildbot.plugins import util
from ursabot.changes import ChangeFilter, GitPoller, GitHubPullrequestPoller
from ursabot.configs import ProjectConfig, MasterConfig
from ursabot.formatters import (BenchmarkCommentFormatter,
                                CrossbowCommentFormatter,
                                MarkdownFormatter)
from ursabot.reporters import GitHubStatusPush, GitHubCommentPush
from ursabot.reporters import ZulipStatusPush
from ursabot.schedulers import AnyBranchScheduler, ForceScheduler, TryScheduler
from ursabot.secrets import SecretInPass
from ursabot.utils import Collection, Config, any_of, has
from ursabot.workers import DockerLatentWorker

from arrow.docker import images
from arrow.builders import (CrossbowTrigger, CppTest, CppCudaTest,
                            CppBenchmark, PythonTest, CppCondaTest,
                            PythonCondaTest, PythonCudaTest, JavaTest,
                            GoTest, RustTest, JSTest, RTest, RCondaTest)


########################### LOAD STATIC CONFIG ################################
# Read ursabot configuration from .toml files, export URSABOT_ENV='test' to use
# test environment. These configurations are merged upon each other, the
# merging order is default.toml <- $env.toml <- local.toml <-.secrets.toml
# The schema of the configuration files are flexible. `conf` is only used by
# this master.cfg file, so it can be freely changed.
# For more see https://github.com/ursa-labs/ursabot#configuring-ursabot

env = os.environ.get('URSABOT_ENV', 'test')

print(f'Loading environment: {env}')
conf = Config.load('default.yaml', f'{env}.yaml',
                   optionals=['local.yaml', '.secrets.yaml'])

################################ WORKERS ######################################
# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

workers = Collection([
    DockerLatentWorker(
        f'{w.name}-docker',
        arch=w.arch,
        tags=w.get('tags', []),
        max_builds=w.get('max_builds', 1),
        properties={'ncpus': w.get('ncpus')},
        autopull=True,
        alwaysPull=True,
        docker_host=w.docker.host,
        masterFQDN=w.docker.get('masterFQDN'),
        volumes=w.docker.get('volumes', []),
        hostconfig=w.docker.get('hostconfig', {}),
        missing_timeout=w.docker.get('missing_timeout', 120)
    )
    for w in conf.arrow.workers
])
cuda_enabled_workers = workers.filter(tags=has('cuda'))

################################ BUILDERS #####################################
# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

arrow_benchmarks = CppBenchmark.builders_for(workers)
arrow_tests = (
    CppTest.builders_for(workers) +
    RTest.builders_for(workers) +
    PythonTest.builders_for(workers) +
    CppCondaTest.builders_for(workers) +
    RCondaTest.builders_for(workers) +
    PythonCondaTest.builders_for(workers) +
    CppCudaTest.builders_for(cuda_enabled_workers) +
    PythonCudaTest.builders_for(cuda_enabled_workers) +
    JavaTest.builders_for(workers) +
    RustTest.builders_for(workers) +
    GoTest.builders_for(workers) +
    JSTest.builders_for(workers)
)

arrow_builders = arrow_tests + arrow_benchmarks
crossbow_builders = CrossbowTrigger.builders_for(workers)
all_builders = arrow_builders + crossbow_builders

print('Enabled builders:')
for builder in all_builders:
    print(f' - {builder}')

################################ SCHEDULERS ###################################
# Configure the Schedulers, which decide how to react to incoming changes.
# For more see http://docs.buildbot.net/latest/full.html#scheduling-builds

schedulers = [
    AnyBranchScheduler(
        name='Arrow',
        change_filter=ChangeFilter(
            project=conf.arrow.name,
            # see docstring of ursabot.hooks.GithubHook
            category=any_of(None, 'tag', 'pull'),
        ),
        treeStableTimer=None,
        builders=arrow_tests
    ),
    AnyBranchScheduler(
        name='ArrowBuild',
        change_filter=ChangeFilter(
            project=conf.arrow.name,
            category='comment',
            properties={'command': 'build'}
        ),
        treeStableTimer=None,
        builders=arrow_tests
    ),
    AnyBranchScheduler(
        name='ArrowBenchmark',
        change_filter=ChangeFilter(
            # ensure that benchmarks are not triggered on every commit of every
            # pull request, see docstring of ursabot.hooks.GithubHook
            project=conf.arrow.name,
            category='comment',
            properties={'command': 'benchmark'}
        ),
        treeStableTimer=None,
        builders=arrow_benchmarks
    ),
    AnyBranchScheduler(
        name='CrossbowTrigger',
        change_filter=ChangeFilter(
            # ensure that benchmarks are not triggered on every commit of every
            # pull request, see docstring of ursabot.hooks.GithubHook
            project=conf.arrow.name,
            category='comment',
            properties={'command': 'crossbow'}
        ),
        treeStableTimer=None,
        builders=crossbow_builders
    ),
    # TODO(kszucs): specialize force scheduler, for example let the user
    # pass crossbow args for the crossbow-force scheduler
    ForceScheduler(
        name='ArrowForce',
        project=conf.arrow.name,
        repository=conf.arrow.repo,
        builders=all_builders
    ),
    TryScheduler(
        name='ArrowTry',
        port=conf.arrow.schedulers['try'].port,
        userpass=conf.arrow.schedulers['try'].userpass,
        builders=all_builders
    )
]

################################ REPORTERS ####################################
# There are multiple ways to present build status to various places e.g.
# to github as status push, reviews and/or comments.

reporters = []

if conf.arrow.reporters.github_status.enabled:
    reporters.append(
        GitHubStatusPush(
            name='ArrowStatusPush',
            tokens=[
                util.Interpolate(token) for token in
                conf.arrow.reporters.github_status.tokens
            ],
            context=util.Interpolate('%(prop:buildername)s'),
            builders=arrow_builders,
            debug=False,
            verbose=True,
            verify=True
        )
    )

if conf.arrow.reporters.github_comment.enabled:
    reporters.extend([
        GitHubCommentPush(
            name='BenchmarkCommentPush',
            tokens=[
                util.Interpolate(token) for token in
                conf.arrow.reporters.github_comment.tokens
            ],
            formatter=BenchmarkCommentFormatter(),
            builders=arrow_benchmarks,
            report_on={'failure', 'exception', 'cancelled', 'success'},
            debug=False,
            verbose=True,
            verify=True
        ),
        GitHubCommentPush(
            name='CrossbowCommentPush',
            tokens=[
                util.Interpolate(token) for token in
                conf.arrow.reporters.github_comment.tokens
            ],
            formatter=CrossbowCommentFormatter(
                crossbow_repo='ursa-labs/crossbow',
            ),
            builders=crossbow_builders,
            report_on={'failure', 'exception', 'cancelled', 'success'},
            debug=False,
            verbose=True,
            verify=True
        )
    ])

if conf.arrow.reporters.zulip_status.enabled:
    reporters.append(
        ZulipStatusPush(
            organization=conf.arrow.reporters.zulip_status.organization,
            bot=conf.arrow.reporters.zulip_status.bot,
            apikey=conf.arrow.reporters.zulip_status.apikey,
            stream=conf.arrow.reporters.zulip_status.stream,
            formatter=MarkdownFormatter(),
            builders=arrow_builders + crossbow_builders,
            report_on={'failure', 'exception', 'cancelled'},
            debug=False,
            verbose=True,
            verify=True
        )
    )

################################ POLLERS ####################################
# Git and Pull request pollers are required only if no hooks are defined.
# Pollers should be set up if the change hooks are not configured for the
# arrow repository.

pollers = []
if conf.arrow.poller.enabled:
    pollers.extend([
        GitPoller(
            project=conf.arrow.name,
            repourl=conf.arrow.repo,
            branch='master',
            pollInterval=180
        ),
        GitHubPullrequestPoller(
            project=conf.arrow.name,
            branches=['master'],
            pollInterval=180,
            magic_link=True,
            token=util.Interpolate('%(secret:ursabot/github_token)s')
        )
    ])

################################ PROJECT CONFIG ###############################
# ProjectConfig is a thin layer around the project specific components.
# It lets other buildmaster configurations to reuse existing configurations,
# and it also makes possible to maintain the project relevant buildbot code
# in the project's own codebase.

arrow = ProjectConfig(
    name=conf.arrow.name,
    images=images,
    workers=workers,
    pollers=pollers,
    builders=all_builders,
    schedulers=schedulers,
    reporters=reporters
)

############################# BUILDMASTER CONFIG ##############################
# `BuildmasterConfig` isthe dictionary that the buildbot buildmaster pays
# attention to.
# - `buildbot checkconfig master.cfg` loads and validates it without actually
#   running the services
# - `buildbot start|stop|restart .` also loads this dictionary, indirectly
#   through buildbot.tac

secret_providers = []
if conf.secrets.enabled:
    secret_providers.append(
        SecretInPass(
            # passphrase should be set either in local.yaml or .secrets.yaml
            # without the interpolate syntax
            passphrase=conf.secrets.get('passphrase'),
            dirname=Path(conf.secrets.directory).expanduser()
        )
    )

BuildmasterConfig = MasterConfig(
    title=conf.title,
    url=conf.url,
    webui_port=conf.webui_port,
    worker_port=conf.worker_port,
    database_url=conf.database_url,
    secret_providers=secret_providers,
    projects=[
        arrow
    ]
)
